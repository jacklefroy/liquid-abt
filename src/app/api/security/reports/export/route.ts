// LIQUID ABT - Security Report Export API
// Generates and exports comprehensive security reports

import { NextRequest, NextResponse } from 'next/server';
import { securityMetricsService } from '@/lib/security/securityMetrics';
import { validateJWT } from '@/lib/auth/jwt';
import { headers } from 'next/headers';

export async function GET(request: NextRequest) {
  try {
    // Extract JWT from Authorization header
    const headersList = headers();
    const authorization = headersList.get('authorization');
    
    if (!authorization || !authorization.startsWith('Bearer ')) {
      return NextResponse.json(
        { error: 'Unauthorized - Missing or invalid token' },
        { status: 401 }
      );
    }

    const token = authorization.substring(7);
    
    // Validate JWT and extract user info
    const userInfo = await validateJWT(token);
    if (!userInfo) {
      return NextResponse.json(
        { error: 'Unauthorized - Invalid token' },
        { status: 401 }
      );
    }

    // Check if user has admin privileges for security reports
    if (userInfo.role !== 'ADMIN' && userInfo.role !== 'OWNER') {
      return NextResponse.json(
        { error: 'Forbidden - Insufficient privileges' },
        { status: 403 }
      );
    }

    // Get query parameters
    const { searchParams } = new URL(request.url);
    const tenantId = headersList.get('x-tenant-id') || userInfo.tenantId;
    const hours = parseInt(searchParams.get('hours') || '24');
    const format = searchParams.get('format') || 'json';

    // Generate comprehensive security report
    const report = await securityMetricsService.generateSecurityReport(
      tenantId !== 'global' ? tenantId : undefined,
      hours
    );

    // Add metadata
    const fullReport = {
      ...report,
      metadata: {
        generatedAt: new Date().toISOString(),
        generatedBy: userInfo.sub,
        tenantId: tenantId !== 'global' ? tenantId : null,
        timeframe: `${hours} hours`,
        reportVersion: '1.0'
      }
    };

    if (format === 'json') {
      return NextResponse.json(fullReport);
    } else if (format === 'csv') {
      // Generate CSV format
      const csvContent = await generateCSVReport(fullReport);
      
      return new NextResponse(csvContent, {
        status: 200,
        headers: {
          'Content-Type': 'text/csv',
          'Content-Disposition': `attachment; filename="security-report-${new Date().toISOString().split('T')[0]}.csv"`
        }
      });
    } else if (format === 'pdf') {
      // For PDF generation, we would typically use a library like puppeteer or jsPDF
      // For now, return a placeholder response
      return NextResponse.json({
        error: 'PDF export not implemented yet',
        availableFormats: ['json', 'csv']
      }, { status: 501 });
    } else {
      return NextResponse.json({
        error: 'Invalid format. Supported formats: json, csv, pdf'
      }, { status: 400 });
    }

  } catch (error) {
    console.error('Security report export API error:', error);
    
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}

async function generateCSVReport(report: any): Promise<string> {
  const lines: string[] = [];
  
  // Header
  lines.push('LIQUID ABT Security Report');
  lines.push(`Generated: ${report.metadata.generatedAt}`);
  lines.push(`Generated By: ${report.metadata.generatedBy}`);
  lines.push(`Timeframe: ${report.metadata.timeframe}`);
  lines.push('');
  
  // Summary
  lines.push('EXECUTIVE SUMMARY');
  lines.push('Metric,Value');
  lines.push(`Total Alerts,${report.summary.totalAlerts}`);
  lines.push(`Critical Alerts,${report.summary.criticalAlerts}`);
  lines.push(`Risk Score,${report.summary.riskScore}`);
  lines.push('');
  
  // Recommended Actions
  if (report.summary.recommendedActions.length > 0) {
    lines.push('RECOMMENDED ACTIONS');
    report.summary.recommendedActions.forEach((action: string, index: number) => {
      lines.push(`${index + 1},"${action}"`);
    });
    lines.push('');
  }
  
  // Metrics by Type
  lines.push('SECURITY METRICS BY TYPE');
  lines.push('Type,Count,Latest Value,Latest Timestamp');
  Object.entries(report.metricsByType).forEach(([type, metrics]: [string, any[]]) => {
    if (metrics.length > 0) {
      const latest = metrics[0];
      lines.push(`${type},${metrics.length},${latest.value},"${latest.timestamp}"`);
    }
  });
  lines.push('');
  
  // Trend Analysis
  if (report.trendAnalysis.length > 0) {
    lines.push('TREND ANALYSIS');
    lines.push('Type,Trend,Percentage Change');
    report.trendAnalysis.forEach((trend: any) => {
      lines.push(`${trend.type},${trend.trend},${trend.percentageChange}%`);
    });
  }
  
  return lines.join('\n');
}